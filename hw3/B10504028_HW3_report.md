# B10504028_HW3_report
## ECB
all of the blocks encrypted with the same key, think there could be some parallel mechanism to do this in order to get higher performance.
My partner write the code of ECB.
這個部份是我的隊友做的,我隊友也做了block generator
## CBC
the cipherText of the previous block cipher become the next block's key.
I finish this by just modify some line of encryption code, but basically all of the CBC mode encryption is programmed by me.
這個部分我用了隊友的block generator來做,但主要是以下的程式碼比較複雜,因為資料要先轉成int型態,才能進行xor運算,然後又要再轉成bytes型態,才能做加密。  
首先宣告一個ECB mode的AES cipher,其實應該要從頭到尾都用同一個cipher,而不是每一次都從新宣告一個,這樣做很沒有效率,但是因為我想要把所有跟加密有關的東西都放在同一個function裡面,所以也只好這麼做
```python=
def CBC_encrypt(text, key, iv):
    cipher_ECB = AES.new(pad(key, 16), AES.MODE_ECB)
```
接下來做把iv和plaintext做xor運算,因為從bytes中取出的資料就己經是int類型了,所以就直接做xor運算,但有些算出來的結果會是0x01這種的,而他的零會被直接忽略變成0x1,所以我們用上了format()來強制數字的變成0x01,這樣在最後轉成bytes型態時才不會發生問題。    
'#04x'的意義,#代表我們要對int操作,format()會按照最後一個參數分別在字串最前面加上0d,0x,0b等等;0是後綴字;4代表的是最後字串的總長度,0x加上我們要的另外兩個數字,所以長度是4;x就是說我們要轉的是hexadicimal 16進位的數字,所以會在最前面加上0x。
```python=
data = ""
for a,b in zip(text, iv):
    c = format(a^b, '#04x')
```
接著就是把數字的部分取出來,轉成bytes型態,最後對他進行加密就完成了。
```python=
    data += c[2:]
cText = bytes.fromhex(data)
cText = cipher_ECB.encrypt(cText)
return cText
```
下面是對於block的操作部分
首先用data_generator,從block裡面依次取出16個字元
```python=
for data in data_generator(pixs, 16): 
    try :
```
接著拿iv來對ciphertext進行解密
```python=
plaintext = CBC_decrypt(data, key, iv)
```
然後拿目前的cipherText當下一次的iv
```python=
iv = data
```
如果以上的操作有失敗的話,就把cipherText給印出來.
```python=
except:
    print(data)
```
如果沒有例外發生的話,就把解密的結果給寫到檔案中,但這裡其實有一個怪怪的地方,就是如果上面的操作發生意外的
```python=
    f_CBC.write(bytes(plaintext))
```
如果所有的檔案都寫完了,就把檔案給關掉
```python=
f_CBC.close()
```
## DIY
I aims to invent an protocol that can quickly generate cipherText with parallel execution. Maybe generate the key once and use for all the data in the recent time.
我一開始的目標是要做出一個可以平行化處理及可以很方便加解密的操作模式,但在各研究之後我發現這些方式都以經被課本給講走了,所以我就把腦筋動到了initial vector 的產生上。首先我想起了資料結構上過樹,樹結構從下到上看起來很像可以把最下面的東西以某一種方式給傳遞到另一個結點上,所以我就想用樹狀結構應該可以做出一個可以有diffusion校果的initial vector產生方式.
I came up with a concept that use a tree structure to build the initial value, which is a little complicate and maybe difficult to implement, but it is a start.
接著我就畫出了下面這張圖,首先p1跟p2的cipherText做一次xor運算後,把結果放到1中,接著拿1當p3、p4的iv,再把p3、p4的結果xor在一起存到2中,此時第一層的樹有了兩個節點,所以就把他們xor在一起然後放到3中,接下來再拿3當做5、6的iv,然後就這樣一直做下去。
我一開始畫出這張圖後,就想用數學的方法去計算每個plaintext對應到的iv,但經過一些研究後發現這樣不可行,因為會牽涉到太多的參數,所以我就開始想有沒有什麼方式可以不用到數學但還是可以找到我要的iv
![](https://i.imgur.com/8TlOm9T.png)
which a tree is created from leaves, the first ciphertext of first two block generate the initail value for 3 and 4 block, and the ciphertext of 3 and 4 xor togather and xor togather with 1 and 2, and do this thing recursively until the last block is encrypt.
The decryption do the same thing. Decrypt and use iv to get the second initial value, and recursively doing so until the last block.
The benefit of this algorithm is it provide another layer of diffusion, which all of the block has the information of all previous block.
### BubbleStack
我的最終方式是用stack來做這件事,因為我發現每次在取iv的時候,我都是取離我最近的那個iv,也就是LIFO,而結合的動作就是如果想要加入的cell有資料存在的話,那就跟他結合並且存到下一層去,這樣我們就有了一個完整的存取定義。
所以我就按照stack的標準存取方式來實做,也就是pop()和push(),當把一組cipherText 做完xor後,就把這個結果給push()到stack中,要取一個新的iv時就pop()這個stack。
### 程式碼解說

但我們測試後的結果就發現,如果我們在stack treel的結合方式是xor,那在遇到一堆一樣的資料時就會發生每兩組會有相同的結果的問題,會可以看到原圖的大致樣貌,如下圖
![](https://i.imgur.com/KiIl2YH.jpg)  
![](https://i.imgur.com/Gmg1GzR.jpg)  
那可以看到我們的圖的複雜度介於ECB和CBC之間,我們猜原因是就算我們己經把前面的資訊帶到後面來,但是因為BubbleStack的成長速度是跟資料長度程log2的關係,所以只要一樣資料重複的長度超過樹的深度,那整顆樹就會被改成跟那一段重複資料有關的東西,所以前面的資訊就會不見,就會出現像圖中那樣的pattern,直到遇不一樣的資料才可以恢複.
下圖是重複的資料比較短的圖,就不會出現像ECB
![](https://i.imgur.com/NErt4P8.jpg)
![](https://i.imgur.com/dmzGgiv.jpg)
基於這樣的原因,我們有必要再改進這個