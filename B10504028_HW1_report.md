# B10504028 HW1 Report 說明文件

## 分工
* 四材料四甲 B10504028 林哲豪
* 隨班附讀 A22727 黃婕雅
## 環境
Windows 10 C++17
## Encrypt 程式說明
### 1.Caesar Cipher
#### demo
> plain text:abc
> key:1
> cipher text:BCD

直接從ASCII Code下手，英文字母大寫是在90結束，小寫是在122結束，所以如果把所有的字元都減掉32再加上key，就可以一次完成平移和大寫轉換，省去呼叫strupr()的麻煩。並且模了一次91再加上65以解決超過90的問題。
```c++
     for(int i=0; i <= strlen(plainText)-1; i++){
        if((plainText[i]-32+key)%91 <= 65){
            cipherText[i]=(plainText[i]-32+key)%91+65;
        }else{
            cipherText[i]=(plainText[i]-32+key);
```
### 2.Playfair Cipher
> plain text:thisisdanielandhestayuplate
> key:hello
> cipher text:QOMQMQGLPKLOOPBLLRUOZTMAOULW

利用鏈結串列生成字元列表，先創造串列的入口，並設定一個current指向串列的頭，以便後續的操作。
```c++
head=(charList*)malloc(sizeof(charList));   //empty head
head->next=NULL;
current=head;
```
判斷plainText的長度是否為偶數，不是偶數的話會影響加密的結果，所以要在最後面加上一個字元(x)，但相對的也會讓解密後的字串最後面多上一個字元(x)，這也是無法避免的錯誤，不過助教的測資不會出現奇數長度，這樣的錯誤並不會出現。
```c
if(strlen(plainText)%2 != 0){
    strcat(plainText, "x");
}
```
把所有的小寫英文字母存進去字元串列中，但跳過j，這樣才不會讓字元表的大小超過25。
```c
    for(int i=0; i<= 25; i++){
        //add all of the character a-i k-z, skip j=9
        if(i == 9){
            //do nothing, to skip j
        }else add(i+97);
    }
```
    **add function**
    add()會把輸入的字元加到串列的最後面去，首先不斷地讓current指向下一個串列端點直到碰到最後一個為止
    ```c
    void add(char character){
        //add to the tail of linked list
        while(current->next != NULL){
            current=current->next;
        }
    ```
再來創建一個新的端點，把新端點的字元設成要加入的字元，再把新的字元接上串列。
```c
    charList *newList;
    newList= new charList;
    newList->character=character;
    newList->next=NULL;
    current->next=newList;
```
接下來要把在plain text中的字元從串列中拿掉，先把plain text中的'j'換成'i'以免又加到'j'
```c
    for(int i=0; i<=strlen(plainText); i++){
        if(plainText[i] == 'j'){
            plainText[i] = 'i';
        }
```
再來就是把plain text中的字元一個接一個地拿掉
```c
    }for(int i=0; i<=strlen(key)-1; i++){
        remove(key[i]);
    }
```
**remove function**


### 3.Vernam Cipher

### 4.Row Cipher

### 5.Rail Fence Cipher