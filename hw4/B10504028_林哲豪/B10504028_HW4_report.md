# B10504028_HW4_report
## 姓名
B10504028 四材四甲 林哲豪
## 環境
python 3.7.4
## 程式碼解析
### 基本款

### 加速款
#### 找乘法反元素
##### 費馬小定理
因為e是質數,所以可以利用費馬小定理  
a<sup>m-1</sup>=1(mod m)  
a<sup>m-2</sup>=a<sup>-1</sup>(mod m)  
所以只要算a<sup>m-2</sup>(mod m),就可以找到a的乘法反元素
* 但是m並不是質數,所以不能用費馬小定理來解
* e和phi_n互質,所以也許可以用extended GCD來找乘法反元素
##### extenede GCD
ax+by=gcd(a,b),如果a,b互質的話   
ax+by=1  
ax+by=ax=1(mod b)
也就是說在a,b互質的情況下,只要找到bezout coefficient中的x,那我們也就找到了a的乘法反元素~~  
所以現在的問題就變成了要怎麼找到bezout coefficient??
```python=
m0 = m 
y = 0
x = 1
if (m == 1) : 
    return 0
while (a > 1) : 
    q = a // m 
    t = m 
    m = a % m 
    a = t 
    t = y
    y = x - q * y 
    x = t 
if (x < 0) : 
    x = x + m0 
return x
```
##### multiply and square
現在有一個大問題,那就是我們雖然在加密時用了multiply and square加速了,但我們在解密的時候用了中國餘式定理來加速,那我們在做power的時候是不是也要用multiply and square呢?
實驗一:兩邊都用multiply and square
實驗二:兩邊都用最原始的
是的我發現問題了,是multiply and square要從第二個bit開始掃起,我把這個問題改掉之後就可以正常加解密了.
並且一定要一個字一個字地加密,不然所有的字一起加密的話,長度會超過n,而導致資料不見.
## 測試結果
我的前幾次測試都發現,出來的p,q有時候會是偶數,一開始我以為只是miller-rabin test的正常誤差,直到我跟同學討論時才發現原來產生的那個亂數必需要是一個奇數,不然miller-rabin test會一直在跑,在改完這個問題之後,就快了許多。
但是只要產生15bits以上的時候就會需要等很久,我也不知道是哪裡出錯了...