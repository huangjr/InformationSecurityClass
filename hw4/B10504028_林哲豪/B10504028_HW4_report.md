# B10504028_HW4_report
## 姓名
B10504028 四材四甲 林哲豪
## 建置環境
Windows 10-python 3.7.4
## 操作方式
因為RSA要解密時輸入的參數有點多,所以我做了一個互動式的程式,只要依照程式給出的要求來輸入各樣參數就可以使用
一開始先啓動主程式,不用帶任何參數
```shell=
$ python RSA.py
```
接來就會出現以下的畫面  
輸入g可以產生指定的位元數的p和q以及公鑰和私鑰  
輸入e可以對資料進行加密  
輸入d可以對資料進行解密  
輸入x可以離開程式  
如果輸入了亂七入糟的東西,他可是不會理你的哦
```shell=
Welcome to RSA program:
>g, generate public key and private key
>e, encrypt
>d, decrypt
>x, exit
>>>
```
輸入g後,程式會問要產生多少bit,接著只要輸入bit的數量就好了,1024bit的要等3秒左右,不是程式壞掉
```shell=
>g, generate public key and private key
>e, encrypt
>d, decrypt
>x, exit
>>> g
>how many bits do you want?
>>> 100
Here is your key information, store in wallet or paper, don't tell others your private key
p= 868266250257073
q= 846363373772563
e= 65537
d= 194579817035889821335140789089
n= 734868752900428800484584088099
```
其它的操作也是類似,就按照程式的要求輸入資料就好
## 執行結果圖
### key generation
![](https://i.imgur.com/jvANjpy.png)
### encryption
![](https://i.imgur.com/vX9oath.png)
cipherText太長,所以沒有辦法全部都弄進來
### decryption
![](https://i.imgur.com/natajQh.png)
...
![](https://i.imgur.com/jjTLq7C.png)
### 執行速度
除了1024 key generation會花超過2秒,encryption 和 decryption都花不到一秒就可以完成,非常地快速
## 程式碼解說
### 檔案結構
我的作業一共有三個檔案
RSA.py, 主程式  
acc_RSA.py, 存加速用程式的地方  
bcolor.py, 幫輸出文字上色的東西,因為是用互動式輸入,所以想說把介面弄得好看一些些.
### 基本款
我沒有做基本款的,直接跳到加速款
### 加速款
## 遇到困難與心得
#### 找乘法反元素
##### 費馬小定理
因為e是質數,所以可以利用費馬小定理  
a<sup>m-1</sup>=1(mod m)  
a<sup>m-2</sup>=a<sup>-1</sup>(mod m)  
所以只要算a<sup>m-2</sup>(mod m),就可以找到a的乘法反元素
* 但是m並不是質數,所以不能用費馬小定理來解
* e和phi_n互質,所以也許可以用extended GCD來找乘法反元素
##### extenede GCD
ax+by=gcd(a,b),如果a,b互質的話   
ax+by=1  
ax+by=ax=1(mod b)
也就是說在a,b互質的情況下,只要找到bezout coefficient中的x,那我們也就找到了a的乘法反元素~~  
所以現在的問題就變成了要怎麼找到bezout coefficient??
```python=
m0 = m 
y = 0
x = 1
if (m == 1) : 
    return 0
while (a > 1) : 
    q = a // m 
    t = m 
    m = a % m 
    a = t 
    t = y
    y = x - q * y 
    x = t 
if (x < 0) : 
    x = x + m0 
return x
```
#### multiply and square
現在有一個大問題,那就是我們雖然在加密時用了multiply and square加速了,但我們在解密的時候用了中國餘式定理來加速,那我們在做power的時候是不是也要用multiply and square呢?  
實驗一:兩邊都用multiply and square  
實驗二:兩邊都用最原始的  
是的我發現問題了,是multiply and square要從第二個bit開始掃起,我把這個問題改掉之後就可以正常加解密了.
並且一定要一個字一個字地加密,不然所有的字一起加密的話,長度會超過n,而導致資料不見.
把這個小bug修正之後就可以用multiply and square來做所有的次方
#### 執行速度
我的前幾次測試都發現,出來的p,q有時候會是偶數,一開始我以為只是miller-rabin test的正常誤差,直到我跟同學討論時才發現原來產生的那個亂數必需要是一個奇數,不然miller-rabin test會一直在跑,在改完這個問題之後,就快了許多。
但是只要產生15bits以上的時候就會需要等很久,我也不知道是哪裡出錯了...  
之後我又把miller rabin test裡面的除法運算元從'/'改成'//',改完這個東西之後就可以很快地產生key了,只能說python真的很多奇怪但很好用的東西